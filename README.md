=======
## README ##

JRSRepair is a research tool that attempts to repair a buggy program by randomly mutating it. It is essentially a Java implementation of the [RSRepair](http://qiyuhua.github.io/projects/rsrepair/) tool, which is a variation of the [GenProg](http://dijkstra.cs.virginia.edu/genprog/) automated program repair tool.

### Installation ###

JRSRepair is an Eclipse plugin.

* Clone the source into a new folder
* Import the project into Eclipse
* Ensure Eclipse plug-in tools are installed
* Create a directory called `lib\` and put the following libraries in it:
    1. [commons-io-2.4.jar](http://commons.apache.org/proper/commons-io/download_io.cgi)
    2. [commons-lang3-3.3.2.jar](http://commons.apache.org/proper/commons-lang/download_lang.cgi)

### Configuring and Running ###

JRSRepair comes with a sample program that will run JRSRepair (ca.uwaterloo.ece.qhanam.jrsrepair.test.SampleUse). This program can be executed from the command line and takes one argument -> the path to the configuration file. A sample configuration file can be found in `sample\config\jsrepair.properties`.

Sample useage:
```bash
java ca.uwaterloo.ece.qhanam.jrsrepair.test.SampleUse /path/to/jrsrepair.properties
```

### Directory Structure ###

* `src\`: The JRSRepair library
* `test\`: Contains the sample program `SampleUse.java` which runs JRSRepair.
* `sample\`: A sample program for trying out JRSRepair
* `sample\src`: The sample program under test (an LRU cache implementation)
* `sample\test`: The JUnit test cases for the sample program under test
* `sample\config`: The JRSRepair configuration files for repairing the sample program. This includes:
    * `jrsrepair.properties`: The configuration file
    * `faulty.cov`: The code coverage file for potentially faulty statements to mutate.
    * `seed.cov`: The code coverage file for seed statements to perform the mutations with.
    * `build.xml`: The Apache Ant build script that runs the JUnit tests for the sample program.

### Output ###

JRSRepair outputs result data to the folder specified by the `build_directory` property in `jrsrepair.properties`. The following outputs are stored in this directory:

* `mutation-log`: A log of the mutation operations performed for each candidate and each generation.
* `compile-log`: A log of compiler errors generated by the JDK compiler. These may occur if all variables are in scope but there are still semantic errors (e.g., a return statement is inserted with the incorrect return type). These may also occur if the original build is not set up correctly.
* `classes_Candidate[x]_Generation[y]_[timestamp]`: If a patch was generated that passes all test cases, the binary is stored in a folder with this signature.
* `test-reports`: A directory containing the reports from the test script (Ant script or custom Bash script). This isn't directly output by JRSRepair, but for running experiments all test results should be logged by the script.

### MFix Evaluation Method ###

JRSRepair is used in the evaluation of [MFix](http://asset.uwaterloo.ca/MFix/), an automated program repair technique. This section describes the steps to replicate the results.

* Localize the fault for the program under repair:
    * Collect code coverage of passing and failing test cases using a tool like [JaCoCo](http://www.eclemma.org/jacoco/)
    * Assign a weight to each statement executed by the failing test cases. A simple metric is to assign a weight of 1.0 to statements that are only executed by failing test cases and 0.1 to statements that are executed by both failing and passing test cases. Better weighting can be achieved using a similarity coefficient such as Jaccard or Ochaiai. 
* Create `faulty.cov`. This is the weighted list of potentially faulty statements using the ranked list of statements executed by the failing test case from step 1. These statements will be selected for mutation according to their weight.
* Create `seed.cov`. This is the set of statements executed by all test cases. These statements will be used for insertion and replacement mutations.
* Set up the Ant build script (build.xml) for running the JUnit tests (Maven will generate this for you if your project uses Maven).
* Check that the Ant JUnit runner fails for the faulty program and passes for the repaired program.
* Set up JRSRepair by editing jrsrepair.properties:
* Use `the null_mutation_only` property to make sure JRSRepair compiles and runs the program under repair correctly without performing mutations.
* Run JRSRepair. If you run JRSRepair more multiple times, increment the seed for the random number generator in between each run.
